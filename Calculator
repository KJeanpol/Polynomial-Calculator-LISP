#lang racket

;----------------------  GETTERS FROM COMMON MONOMIAL ELEMENTS ---------------------
(define (getCoef mon) (car mon))
(define (getX mon) (cond [(null? mon) false] [else (first(cdr mon))]))
(define (getY mon) (second(cdr mon)))
(define (getNewMonomial coef x y) (list coef x y))

;-----------------------  USEFUL MONOMIAL FUNCTIONS -----------------------

(define (operadorCoef mon mon2 operador) (operador (getCoef mon) (getCoef mon2)))

(define (areMonomialEqual mon mon2) (equal? (cdr mon) (cdr mon2)))

(define(operadorMonomial monToEval operador pol2 )
  (cond
    [(areMonomialEqual monToEval pol2)
     (getNewMonomial (operadorCoef monToEval pol2 operador) (getX monToEval)(getY monToEval))
     ]
     [else false]))

(define (multiplyMon mon mon2)
  (getNewMonomial (* (getCoef mon) (getCoef mon2)) (+ (getX mon) (getX mon2)) (+ (getY mon) (getY mon2))))

;----------------------  GETTERS FROM COMMON POLYNOMIAL ELEMENTS ---------------------
(define (concatenatePol pol operador pol2)
  (cond
    [(equal? operador -)(append pol (negativePol pol2))]
    [else (append pol pol2)]
    )
  )

(define (getFirstConcatenated pol operador pol2) (car(concatenatePol pol operador pol2)))
(define (getSecondConcatenated pol operador pol2) (cdr(concatenatePol pol operador pol2)))
(define (getFirstEvaluatedValue pol operador pol2) (car(getEvaluatedValues (getFirstConcatenated pol operador pol2) (getSecondConcatenated pol operador pol2) '())))
(define (getSecondtEvaluatedValue pol operador pol2) (car (cdr(getEvaluatedValues (getFirstConcatenated pol operador pol2) (getSecondConcatenated pol operador pol2) '()))))


;------------------  ARITHMETICS FUNCTIONS WITHIN THE POLYNOMIAL ! -----------------------

(define (negativePol pol) (map (lambda (x) (getNewMonomial (* (getCoef x) -1) (getX x) (getY x))) pol))

(define (OperadorPolynomial pol operador pol2) (myOutput (Operador pol operador pol2) ""))
(define (Operador pol operador pol2)(operadorPolynomial (inputAux pol) operador (inputAux pol2)))

(define (operadorPolynomial pol operador pol2)
  (cond
    [(equal? operador *)
     (multiplyPol pol pol2 '())
     ]
    [else (polynomialAddition (getFirstEvaluatedValue pol operador pol2) (getSecondtEvaluatedValue pol operador pol2) '())]
  )
  )

;-----------------------------FUNCTIONS TO ADDITION--------------------------------------
(define (polynomialAddition mon pol answer)
  (cond
    [(null? pol) (car (list (append answer (list mon))))]
    [else
     (polynomialAddition
      (car(getEvaluatedValues (car pol) (cdr pol) '()))
      (first(cdr (getEvaluatedValues (car pol) (cdr pol) '())))
      (cond
        [(equal? (getCoef mon) 0) answer]
        [else (append answer (list mon))]
        )
      )
     ]
    )
  )

(define (getEvaluatedValues mon polFlag answer)
  (cond
    ((empty? polFlag) (append(list mon) (list answer)))
       (else (cond
               [(areMonomialEqual mon (car polFlag))
               (getEvaluatedValues (operadorMonomial mon + (car polFlag)) (cdr polFlag) answer)]
               [else (getEvaluatedValues mon (cdr polFlag) (append answer (list (car polFlag))))]))))

;-----------------------------FUNCTIONS TO MULTIPLY--------------------------------------

(define (multiplyPol pol pol2 polFinal)
  (cond
    [(null? pol) (polynomialAddition (car polFinal) (cdr polFinal) '())]
    [else (multiplyPol (cdr pol) pol2 (append polFinal (multiplyPolAux (car pol) pol2)))]
    ))

(define (multiplyPolAux mon pol2) (map (lambda (x)  (multiplyMon mon x)) pol2))

;-----------------------------FUNCTIONS TO RAISED BY AN EXPONENT--------------------------------------

(define (getExp num exp) (cond[(equal? num 0) 1]
                              [else (expt num exp)]))

;-----------------------------FUNCTIONS TO EVAL--------------------------------------
(define (evalAuxTwo pol x y)
  (* (first pol) (* (getExp x (second pol)) (getExp y (third pol)))))

(define (evalAux pol x y) (map (lambda (w)  (evalAuxTwo w x y)) pol))

(define (eval pol x y)(iterateList (evalAux pol x y) 0))

(define (iterateList mySum total)
  (cond
    [(empty? mySum)
     total]
    [else (iterateList (cdr mySum) (+ total (car mySum)))]))

(define (Eval pol x y)(eval (inputAux pol) x y))

;-----------------------  INPUT FUNCTIONS  -----------------------
;pol must be a string
(define (polinomio-input? pol)
  (cond[(regexp-match-exact? #rx"-?[0-9] [0-9] [0-9]( \\| -?[0-9] [0-9] [0-9])*" pol)
        (map (lambda (x)
         (map (lambda(y) (string->number (string y))) (string->list x))
         )
   (string-split
    (string-replace pol " " "") "|"
    )
   )]
       [else (write "ERROR: Invalid input format")]
       )
  )

(define (polinomio-output pol)(format "hola" (car pol)))

(define (makeNegative mon)
  (cond
    [(equal? (car mon) #f)
     (getNewMonomial (* -1 (second mon)) (third mon) (fourth mon))]
    [else mon]))

(define (inputAux input) (map (lambda(x) (makeNegative x)) (polinomio-input? input)))

;-----------------------  OUTPUT FUNCTIONS  -----------------------

(define (returnStringMon mon)
  (string-append (number->string (car mon)) " " (number->string (second mon)) " " (number->string (third mon))))

(define (myOutput pol strFinal)
  (cond
    [(empty? pol) strFinal]
    [else (cond[(empty? (cdr pol)) (myOutput (cdr pol) (string-append strFinal (string-append " " (returnStringMon (car pol)))))]
               [else (myOutput (cdr pol) (string-append strFinal (string-append " " (returnStringMon (car pol)) " |")))])]))

;-----------------------  TEST VALUES GIVEN BY THE TEACHER  -----------------------

(OperadorPolynomial "1 2 0 | -2 1 1 | 1 0 2" + "1 2 1 | 1 2 0 | 2 1 1 | -1 0 2" )
(OperadorPolynomial "1 2 0 | -2 1 1 | 1 0 2" - "1 2 1 | 1 2 0 | 2 1 1 | -1 0 2")
(OperadorPolynomial "2 1 1 | -2 0 0" * "1 2 0 | -2 1 1 | 1 0 0")
(Eval "1 2 0 | -2 1 1 | 1 0 0" 3 5)
